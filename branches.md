## Что такое ветвление? 

Для начала представим, что вы работаете над своим проектом и уже имеете пару коммитов. 

Вы решили, что вы будете работать над проблемой №53 из системы отслеживания ошибок, используемой вашей компанией. Разумеется, Git не привязан к какой-то определенной системе отслеживания ошибок. Так как проблема №53 является обособленной задачей, над которой вы собираетесь работать, мы создадим новую ветку и будем работать на ней. Чтобы создать ветку и сразу же перейти на неё, вы можете выполнить команду `git checkout` с ключом `-b`:

>git checkout -b iss53   
Switched to a new branch "iss53"

Это сокращение для:

>  git branch iss53   
$ git checkout iss53

 <p align = "center"> <img src="./assets/18333fig0311-tn.png">

 Во время работы над своим веб-сайтом вы делаете несколько коммитов. Эти действия сдвигают ветку iss53 вперёд потому, что вы на неё перешли (то есть ваш **HEAD** указывает на неё):

> vim index.html  
> git commit -a -m 'added a new footer [issue 53]'

Теперь вы получаете звонок о том, что есть проблема с веб-сайтом, которую необходимо немедленно устранить. С Git'ом вам нет нужды делать исправления для неё поверх тех изменений, которые вы уже сделали в iss53, и нет необходимости прикладывать много усилий для отмены этих изменений перед тем, как вы сможете начать работать над решением срочной проблемы. Всё, что вам нужно сделать, это перейти на ветку *master*.

Однако, прежде чем сделать это, учтите, что если в вашем рабочем каталоге или индексе имеются **незафиксированные изменения**, которые конфликтуют с веткой, на которую вы переходите, Git не позволит переключить ветки. Лучше всего при переключении веток иметь чистое рабочее состояние. На данный момент представим, что все изменения были добавлены в коммит, и теперь вы можете переключиться обратно на ветку master:

> git checkout master   
> Switched to branch "master"

Теперь рабочий каталог проекта находится точно в таком же состоянии, что и в момент начала работы над проблемой №53, так что вы можете сконцентрироваться на исправлении срочной проблемы. Очень важно запомнить: **Git возвращает ваш рабочий каталог к снимку состояния того коммита, на который указывает ветка, на которую вы переходите**. Он добавляет, удаляет и изменяет файлы автоматически, чтобы гарантировать, что состояние вашей рабочей копии идентично последнему коммиту на ветке.

Итак, вам надо срочно исправить ошибку. Давайте создадим для этого ветку, на которой вы будете работать :

> git checkout -b hotfix    
> Switched to a new branch "hotfix"
> vim index.html     
> git commit -a -m 'fixed the broken email address'     
    
    [hotfix]: created 3a0874c: "fixed the broken email address" 
    1 files changed, 0 insertions(+), 1 deletions(-)

 Можно запустить тесты, убедиться, что решение работает, и слить *(merge)* изменения назад в ветку master, чтобы включить их в продукт. Это делается с помощью команды `git merge`:

> git checkout master  
> git merge hotfix  
> Updating f42c576..3a0874c

    Fast forward
    README |    1 -
    1 files changed, 0 insertions(+), 1 deletions(-)
   
В этом слиянии появляется "Fast forward". Так как ветка, которую мы слили, указывала на коммит, являющийся прямым родителем коммита, на котором мы сейчас находимся, Git просто сдвинул её указатель вперёд. Иными словами, когда вы пытаетесь слить один коммит с другим таким, которого можно достигнуть, проследовав по истории первого коммита, Git поступает проще, перемещая указатель вперёд, так как нет расходящихся изменений, которые нужно было бы сливать воедино. Это называется "перемотка" *(fast forward)*.

Ваши изменения теперь в снимке состояния коммита, на который указывает ветка *master*, и вы можете включить изменения в продукт.

После того как очень важная проблема решена, вы готовы вернуться обратно к тому, над чем вы работали перед тем, как вас прервали. Однако, сначала удалите ветку hotfix, так как она больше не нужна — ветка master уже указывает на то же место. Вы можете удалить ветку с помощью опции `-d` к `git branch`:

> git branch -d hotfix   
> Deleted branch hotfix (3a0874c).

Теперь вы можете вернуться обратно к рабочей ветке для проблемы №53 и продолжить работать над ней:

> git checkout iss53  
>Switched to branch "iss53"  
> vim index.html  
> git commit -a -m 'finished the new footer [issue 53]'

    [iss53]: created ad82d7a: "finished the new footer [issue 53]"
    1 files changed, 1 insertions(+), 0 deletions(-)



<p align = "center"> <img src="./assets/18333fig0315-tn.png">

Стоит напомнить, что работа, сделанная на ветке *hotfix*, не включена в файлы на ветке iss53. Если вам это необходимо, вы можете слить ветку *master* в ветку iss53 посредством команды git merge master. Или же вы можете подождать с интеграцией изменений до тех пор, пока не решите включить изменения на iss53 в продуктовую ветку *master*.

---

Допустим, вы разобрались с проблемой №53 и готовы объединить эту ветку и свой *master*. Чтобы сделать это, мы сольём ветку iss53 в ветку *master* точно так же, как мы делали это ранее с веткой *hotfix*. Всё, что вам нужно сделать, — перейти на ту ветку, в которую вы хотите слить свои изменения, и выполнить команду `git merge`:

> git checkout master  
> git merge iss53  
> Merge made by recursive.  
 
    README |    1 +
    1 files changed, 1 insertions(+), 0 deletions(-)

Это слияние немного отличается от слияния, сделанного ранее для ветки *hotfix*. В данном случае история разработки разделилась в некоторой точке. Так как коммит на той ветке, на которой вы находитесь, не является прямым предком для ветки, которую вы сливаете, Git'у придётся проделать кое-какую работу. В этом случае Git делает простое трёхходовое слияние, используя при этом те два снимка состояния репозитория, на которые указывают вершины веток, и общий для этих двух веток снимок-прародитель. 

Вместо того чтобы просто передвинуть указатель ветки вперёд, Git создаёт новый снимок состояния, который является результатом трёхходового слияния, и автоматически создаёт новый коммит, который указывает на этот новый снимок состояния. Такой коммит называют **коммит-слияние**, так как он является особенным из-за того, что имеет больше одного предка.

Стоит отметить, что Git сам определяет наилучшего общего предка для слияния веток.

Теперь, когда вы осуществили слияние ваших наработок, ветка iss53 вам больше не нужна. Можете удалить её и затем вручную закрыть карточку (ticket) в своей системе:

> git branch -d iss53 

Про возникающие конфликты при слиянии можно посмотреть дополнителью информацию [тут](https://webdevkin.ru/courses/git/git-conflicts) или во вкладке [Дополнительная информация](./addtional%20info.md). <p align = "right"> [![](/assets/pngwing.com-2.png)](./readme.md "домой") 